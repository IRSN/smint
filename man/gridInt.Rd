% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GridInt.R
\name{gridInt}
\alias{gridInt}
\title{Grid interpolation in arbitrary dimension}
\usage{
gridInt(
  X,
  Y,
  Xout,
  interpFun = function(x, y, xout) approx(x = x, y = y, xout = xout)$y,
  intOrder = NULL,
  useC = TRUE,
  trace = 1L,
  out_of_bounds = stop,
  ...
)
}
\arguments{
\item{X}{An object that can be coerced into \code{Grid}. This
can be a data frame or a matrix in \emph{Scattered Data style}:
the number of columns is then equal to the spatial dimension
\eqn{d}, and the number of rows is then equal to the number of
nodes \eqn{n}. But it can also be a \code{Grid} object
previously created.  A data frame or matrix \code{X} will first be
coerced into \code{Grid} by using the the S3 method
\code{\link{as.Grid}}.}

\item{Y}{Response to be interpolated. It must be a vector with
length \eqn{n} equal to the number of nodes. When \code{X}
is a matrix or a data frame, the elements in \code{Y}
match rows of \code{X}, so \code{Y[i]} is the value of the
interpolated function at \code{X[i, ]}. If instead \code{X}
is an object with call \code{"Grid"} the order elements
of \code{Y} must be given in the order associated with the
object \code{X}.}

\item{Xout}{Interpolation locations. Can be a vector or a
matrix. In the first case, the length of the vector must be equal
to the spatial dimension \eqn{d} as given by the number of columns
of \code{X} if this is a matrix, or by \code{dim(X)} if \code{X}
is a \code{Grid} object.  In the second case, each row will be
considered as a response to be interpolated, and the number of
columns of \code{Xout} must be equal to the spatial dimension.}

\item{interpFun}{The function to interpolate. This function must
have as its first 3 formals 'x', 'y', and 'xout', as does
\code{\link{approx}}.  It must also return the vector of
interpolated values as DOES NOT \code{approx}. In most cases, a
simple wrapper will be enough to use an existing method of
interpolation, see \bold{Examples}.}

\item{intOrder}{Order of the one-dimensional interpolations. Must
be a permutation of \code{1:d} where \code{d} is the spatial
dimension.  By default, the interpolation order is \eqn{d},
\eqn{d-1}, \dots, \eqn{1}, corresponding to \code{intOrder =
d:1L}. Note that for the first element of \code{intOrder}, a
vector of length \code{nrow(Xout)} is passed as \code{xout} formal
to \code{interpFun}, while the subsequent \code{interFun} calls
use a \code{xout} of length \code{1}. So the choice of the first
element can have an impact on the computation time.}

\item{useC}{Logical. If \code{TRUE} the computation is done using
a C program via the \code{.Call}. Otherwise, the computation is
done entirely in R by repeated use of the \code{apply} function.
Normally \code{useC = TRUE} should be faster, but it is not always
the case.}

\item{trace}{Level of verbosity.}

\item{out_of_bounds}{Function to handle Xout outside x (default is stop). Then Xout will be bounded by x range.}

\item{...}{Further arguments to be passed to \code{interpFun}.}
}
\value{
A single interpolated value when \code{Xout} is either a
vector or a row matrix.  If \code{Xout} is a matrix with several
rows, the result is a vector of interpolated values, in the order
of the rows of \code{Xout}.
}
\description{
*****************************************************************************
Grid interpolation in arbitrary dimension.
}
\details{
The grid interpolation is performed by looping over
dimensions. For each dimension, a one-dimensional interpolation is
carried out, leading to a collection of interpolation problems
each with a dimension reduced by one.
}
\note{
A future multivariate version to come will allow the
simultaneous interpolation of several \emph{ responses}. Most
probably, this possibility will be used by using a different rule
for the object \code{Y} (matrix or list).

When \code{X} is a \code{Grid} object and \code{Y} is a
vector, \emph{the user must ensure that the order of nodes is the
same for inputs and output}. If so, the order of the dimensions in
\code{X} can be changed using the generalised transposition
\code{aperm}. This will change the order of the univariate
interpolations with possible effects on the computation time
and on the result when the univariate interpolation method is
not linear (w.r.t. the response).

%% Recall that default rule for flat
%% format is that \emph{smaller indices vary faster}. Thus, with
%% inputs \eqn{X_1}{X1}, \eqn{X_2}{X2}, a flat format representation
%% will contain a first block of lines with \eqn{X_2}{X2} equal to its
%% first level, while \eqn{X_1}{X1} runs through all its levels.

When \code{X} is a data frame or a matrix and \code{Y} is a
vector, the values in \code{Y} are matched to the rows of \code{X}
is the same as the order. This situation typically arises when
\code{X} and \code{Y} are columns extracted from a same data
frame.
}
\examples{
set.seed(12345)
##========================================================================
## Select Interpolation Function. This function must have its first 3
## formals 'x', 'y', and 'xout', as does 'approx'. It must also return
## the vector of interpolated values as DOES NOT 'approx'. So a wrapper
## must be xritten.
##=======================================================================
myInterp <- function(x, y, xout) approx(x = x, y = y, xout = xout)$y

##=======================================================================
## ONE interpolation, d = 2. 'Xout' is a vector.
##=======================================================================
myFun1 <- function(x) exp(-x[1]^2 - 3 * x[2]^2)
myGD1 <- Grid(nlevels = c("X" = 8, "Y" = 12))
Y1 <- apply_Grid(myGD1, myFun1)
Xout1 <- runif(2)
GI1 <- gridInt(X = myGD1,  Y = Y1, Xout = Xout1, interpFun = myInterp)
c(true = myFun1(Xout1), interp = GI1)

##=======================================================================
## ONE interpolation, d = 7. 'Xout' is a vector.
##=======================================================================
d <- 7; a <- runif(d); myFun2 <- function(x) exp(-crossprod(a, x^2))
myGD2 <- Grid(nlevels = rep(4L, time = d))
Y2 <- apply_Grid(myGD2, myFun2)
Xout2 <- runif(d)
GI2 <- gridInt(X = myGD2,  Y = Y2, Xout = Xout2, interpFun = myInterp)
c(true = myFun2(Xout2), interp = GI2)

##=======================================================================
## n interpolations, d = 7. 'Xout' is a matrix. Same grid data and
## response as before
##=======================================================================
n <- 30
Xout3 <- matrix(runif(n * d), ncol = d)
GI3 <- gridInt(X = myGD2,  Y = Y2, Xout = Xout3, interpFun = myInterp)
cbind(true = apply(Xout3, 1, myFun2), interp = GI3)

##======================================================================
## n interpolation, d = 5. 'Xout' is a matrix. Test the effect of the
## order of interpolation.
##=======================================================================
d <- 5; a <- runif(d); myFun4 <- function(x) exp(-crossprod(a, x^2))
myGD4 <- Grid(nlevels = c(3, 4, 5, 2, 6))
Y4 <- apply_Grid(myGD4, myFun4)
n <- 100
Xout4 <- matrix(runif(n * d), ncol = d)
t4a <- system.time(GI4a <- gridInt(X = myGD4,  Y = Y4, Xout = Xout4,
                                   interpFun = myInterp))
t4b <- system.time(GI4b <- gridInt(X = myGD4,  Y = Y4, Xout = Xout4,
                                   interpFun = myInterp,
                                   intOrder = 1L:5L))
cbind(true = apply(Xout4, 1, myFun4), inta = GI4a, intb = GI4b)
}
\author{
Yves Deville
}
